{"ast":null,"code":"import { useEffect, useCallback, useState } from 'react';\nvar config = {\n  root: null,\n  rootMargin: '0px 0px 0px 0px',\n  threshold: [0, 1]\n};\n/**\n *\n * useInViewRef hook\n *\n * Returns a mutation observer for a React Ref and true/false when element enters/leaves the viewport. Also fires a callback.\n *\n * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation\n * @param {IntersectionObserverInit} options\n */\n\nfunction useInViewRef(callback, options) {\n  if (callback === void 0) {\n    callback = function () {};\n  }\n\n  if (options === void 0) {\n    options = config;\n  }\n\n  var _a = options.root,\n      root = _a === void 0 ? null : _a,\n      rootMargin = options.rootMargin,\n      threshold = options.threshold;\n\n  var _b = useState(null),\n      node = _b[0],\n      setNode = _b[1];\n\n  var _c = useState(false),\n      inView = _c[0],\n      setInView = _c[1];\n\n  useEffect(function () {\n    // Create an observer instance linked to the callback function\n    if (node) {\n      var observer_1 = new IntersectionObserver(function (entries, observerRef) {\n        entries.forEach(function (_a) {\n          var isIntersecting = _a.isIntersecting;\n          return setInView(isIntersecting);\n        });\n        callback(entries, observerRef);\n      }, options); // Start observing the target node for configured mutations\n\n      observer_1.observe(node);\n      return function () {\n        observer_1.disconnect();\n      };\n    }\n  }, [node, callback, root, rootMargin, threshold]);\n  var ref = useCallback(function (node) {\n    setNode(node);\n  }, []);\n  return [ref, inView];\n}\n\nexport { useInViewRef };","map":{"version":3,"sources":["D:/react/productwebsite/APP/canvas/node_modules/rooks/dist/esm/hooks/useInViewRef.js"],"names":["useEffect","useCallback","useState","config","root","rootMargin","threshold","useInViewRef","callback","options","_a","_b","node","setNode","_c","inView","setInView","observer_1","IntersectionObserver","entries","observerRef","forEach","isIntersecting","observe","disconnect","ref"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,WAApB,EAAiCC,QAAjC,QAAiD,OAAjD;AACA,IAAIC,MAAM,GAAG;AACTC,EAAAA,IAAI,EAAE,IADG;AAETC,EAAAA,UAAU,EAAE,iBAFH;AAGTC,EAAAA,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ;AAHF,CAAb;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,OAAhC,EAAyC;AACrC,MAAID,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,IAAAA,QAAQ,GAAG,YAAY,CAAG,CAA1B;AAA6B;;AACxD,MAAIC,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAGN,MAAV;AAAmB;;AAC7C,MAAIO,EAAE,GAAGD,OAAO,CAACL,IAAjB;AAAA,MAAuBA,IAAI,GAAGM,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAArD;AAAA,MAAyDL,UAAU,GAAGI,OAAO,CAACJ,UAA9E;AAAA,MAA0FC,SAAS,GAAGG,OAAO,CAACH,SAA9G;;AACA,MAAIK,EAAE,GAAGT,QAAQ,CAAC,IAAD,CAAjB;AAAA,MAAyBU,IAAI,GAAGD,EAAE,CAAC,CAAD,CAAlC;AAAA,MAAuCE,OAAO,GAAGF,EAAE,CAAC,CAAD,CAAnD;;AACA,MAAIG,EAAE,GAAGZ,QAAQ,CAAC,KAAD,CAAjB;AAAA,MAA0Ba,MAAM,GAAGD,EAAE,CAAC,CAAD,CAArC;AAAA,MAA0CE,SAAS,GAAGF,EAAE,CAAC,CAAD,CAAxD;;AACAd,EAAAA,SAAS,CAAC,YAAY;AAClB;AACA,QAAIY,IAAJ,EAAU;AACN,UAAIK,UAAU,GAAG,IAAIC,oBAAJ,CAAyB,UAAUC,OAAV,EAAmBC,WAAnB,EAAgC;AACtED,QAAAA,OAAO,CAACE,OAAR,CAAgB,UAAUX,EAAV,EAAc;AAC1B,cAAIY,cAAc,GAAGZ,EAAE,CAACY,cAAxB;AACA,iBAAON,SAAS,CAACM,cAAD,CAAhB;AACH,SAHD;AAIAd,QAAAA,QAAQ,CAACW,OAAD,EAAUC,WAAV,CAAR;AACH,OANgB,EAMdX,OANc,CAAjB,CADM,CAQN;;AACAQ,MAAAA,UAAU,CAACM,OAAX,CAAmBX,IAAnB;AACA,aAAO,YAAY;AACfK,QAAAA,UAAU,CAACO,UAAX;AACH,OAFD;AAGH;AACJ,GAhBQ,EAgBN,CAACZ,IAAD,EAAOJ,QAAP,EAAiBJ,IAAjB,EAAuBC,UAAvB,EAAmCC,SAAnC,CAhBM,CAAT;AAiBA,MAAImB,GAAG,GAAGxB,WAAW,CAAC,UAAUW,IAAV,EAAgB;AAClCC,IAAAA,OAAO,CAACD,IAAD,CAAP;AACH,GAFoB,EAElB,EAFkB,CAArB;AAGA,SAAO,CAACa,GAAD,EAAMV,MAAN,CAAP;AACH;;AACD,SAASR,YAAT","sourcesContent":["import { useEffect, useCallback, useState } from 'react';\nvar config = {\n    root: null,\n    rootMargin: '0px 0px 0px 0px',\n    threshold: [0, 1],\n};\n/**\n *\n * useInViewRef hook\n *\n * Returns a mutation observer for a React Ref and true/false when element enters/leaves the viewport. Also fires a callback.\n *\n * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation\n * @param {IntersectionObserverInit} options\n */\nfunction useInViewRef(callback, options) {\n    if (callback === void 0) { callback = function () { }; }\n    if (options === void 0) { options = config; }\n    var _a = options.root, root = _a === void 0 ? null : _a, rootMargin = options.rootMargin, threshold = options.threshold;\n    var _b = useState(null), node = _b[0], setNode = _b[1];\n    var _c = useState(false), inView = _c[0], setInView = _c[1];\n    useEffect(function () {\n        // Create an observer instance linked to the callback function\n        if (node) {\n            var observer_1 = new IntersectionObserver(function (entries, observerRef) {\n                entries.forEach(function (_a) {\n                    var isIntersecting = _a.isIntersecting;\n                    return setInView(isIntersecting);\n                });\n                callback(entries, observerRef);\n            }, options);\n            // Start observing the target node for configured mutations\n            observer_1.observe(node);\n            return function () {\n                observer_1.disconnect();\n            };\n        }\n    }, [node, callback, root, rootMargin, threshold]);\n    var ref = useCallback(function (node) {\n        setNode(node);\n    }, []);\n    return [ref, inView];\n}\nexport { useInViewRef };\n"]},"metadata":{},"sourceType":"module"}