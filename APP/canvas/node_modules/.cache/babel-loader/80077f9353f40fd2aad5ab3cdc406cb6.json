{"ast":null,"code":"import { useMemo } from 'react';\n/**\n * Credit to material-ui for this snippet\n */\n\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n/**\n * useForkRef\n * Joins refs together and returns a combination of the two as a new ref\n *\n * @param refA\n * @param refB\n */\n\n\nfunction useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n\nexport { useForkRef };","map":{"version":3,"sources":["D:/react/productwebsite/APP/canvas/node_modules/rooks/dist/esm/hooks/useForkRef.js"],"names":["useMemo","setRef","ref","value","current","useForkRef","refA","refB","refValue"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,GAAhB,EAAqBC,KAArB,EAA4B;AACxB,MAAI,OAAOD,GAAP,KAAe,UAAnB,EAA+B;AAC3BA,IAAAA,GAAG,CAACC,KAAD,CAAH;AACH,GAFD,MAGK,IAAID,GAAJ,EAAS;AACVA,IAAAA,GAAG,CAACE,OAAJ,GAAcD,KAAd;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAoBC,IAApB,EAA0BC,IAA1B,EAAgC;AAC5B;AACJ;AACA;AACA;AACA;AACI,SAAOP,OAAO,CAAC,YAAY;AACvB,QAAIM,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;AAC9B,aAAO,IAAP;AACH;;AACD,WAAO,UAAUC,QAAV,EAAoB;AACvBP,MAAAA,MAAM,CAACK,IAAD,EAAOE,QAAP,CAAN;AACAP,MAAAA,MAAM,CAACM,IAAD,EAAOC,QAAP,CAAN;AACH,KAHD;AAIH,GARa,EAQX,CAACF,IAAD,EAAOC,IAAP,CARW,CAAd;AASH;;AACD,SAASF,UAAT","sourcesContent":["import { useMemo } from 'react';\n/**\n * Credit to material-ui for this snippet\n */\nfunction setRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref) {\n        ref.current = value;\n    }\n}\n/**\n * useForkRef\n * Joins refs together and returns a combination of the two as a new ref\n *\n * @param refA\n * @param refB\n */\nfunction useForkRef(refA, refB) {\n    /**\n     * This will create a new function if the ref props change and are defined.\n     * This means react will call the old forkRef with `null` and the new forkRef\n     * with the ref. Cleanup naturally emerges from this behavior\n     */\n    return useMemo(function () {\n        if (refA == null && refB == null) {\n            return null;\n        }\n        return function (refValue) {\n            setRef(refA, refValue);\n            setRef(refB, refValue);\n        };\n    }, [refA, refB]);\n}\nexport { useForkRef };\n"]},"metadata":{},"sourceType":"module"}