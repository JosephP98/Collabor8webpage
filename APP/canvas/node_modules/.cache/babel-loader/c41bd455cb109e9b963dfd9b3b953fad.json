{"ast":null,"code":"// See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nimport { useState, useEffect, useRef } from \"react\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\n/**\n *\n * useInterval hook\n *\n * Declaratively creates a setInterval to run a callback after a fixed\n * amount of time\n *\n *@param {funnction} callback - Callback to be fired\n *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired\n *@param {boolean} startImmediate - Whether the interval should start immediately on initialise\n *@returns {IntervalHandler}\n */\n\nfunction useInterval(callback, intervalDuration, startImmediate) {\n  if (startImmediate === void 0) {\n    startImmediate = false;\n  }\n\n  useWarningOnMountInDevelopment(\"useInterval is deprecated, it will be removed in rooks v7. Please use useIntervalWhen instead.\");\n  var internalIdRef = useRef(null);\n\n  var _a = useState(startImmediate),\n      isRunning = _a[0],\n      setIsRunning = _a[1];\n\n  var savedCallback = useRef();\n\n  function start() {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }\n\n  function stop() {\n    if (isRunning) {\n      setIsRunning(false);\n    }\n  } // Remember the latest callback.\n\n\n  useEffect(function () {\n    savedCallback.current = callback;\n  }); // Set up the interval.\n\n  useEffect(function () {\n    function tick() {\n      savedCallback.current && savedCallback.current();\n    }\n\n    if (intervalDuration !== null && isRunning) {\n      var id_1 = setInterval(tick, intervalDuration);\n      internalIdRef.current = id_1;\n      return function () {\n        internalIdRef.current = null;\n        clearInterval(id_1);\n      };\n    }\n  }, [intervalDuration, isRunning]);\n  var handler;\n  handler = [start, stop, internalIdRef.current];\n  handler.start = start;\n  handler.stop = stop;\n  handler.intervalId = internalIdRef.current;\n  return handler;\n}\n\nexport { useInterval };","map":{"version":3,"sources":["D:/react/productwebsite/APP/canvas/node_modules/rooks/dist/esm/hooks/useInterval.js"],"names":["useState","useEffect","useRef","useWarningOnMountInDevelopment","useInterval","callback","intervalDuration","startImmediate","internalIdRef","_a","isRunning","setIsRunning","savedCallback","start","stop","current","tick","id_1","setInterval","clearInterval","handler","intervalId"],"mappings":"AAAA;AACA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,MAA9B,QAA4C,OAA5C;AACA,SAASC,8BAAT,QAA+C,kCAA/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,QAArB,EAA+BC,gBAA/B,EAAiDC,cAAjD,EAAiE;AAC7D,MAAIA,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAAEA,IAAAA,cAAc,GAAG,KAAjB;AAAyB;;AAC1DJ,EAAAA,8BAA8B,CAAC,gGAAD,CAA9B;AACA,MAAIK,aAAa,GAAGN,MAAM,CAAC,IAAD,CAA1B;;AACA,MAAIO,EAAE,GAAGT,QAAQ,CAACO,cAAD,CAAjB;AAAA,MAAmCG,SAAS,GAAGD,EAAE,CAAC,CAAD,CAAjD;AAAA,MAAsDE,YAAY,GAAGF,EAAE,CAAC,CAAD,CAAvE;;AACA,MAAIG,aAAa,GAAGV,MAAM,EAA1B;;AACA,WAASW,KAAT,GAAiB;AACb,QAAI,CAACH,SAAL,EAAgB;AACZC,MAAAA,YAAY,CAAC,IAAD,CAAZ;AACH;AACJ;;AACD,WAASG,IAAT,GAAgB;AACZ,QAAIJ,SAAJ,EAAe;AACXC,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACH;AACJ,GAf4D,CAgB7D;;;AACAV,EAAAA,SAAS,CAAC,YAAY;AAClBW,IAAAA,aAAa,CAACG,OAAd,GAAwBV,QAAxB;AACH,GAFQ,CAAT,CAjB6D,CAoB7D;;AACAJ,EAAAA,SAAS,CAAC,YAAY;AAClB,aAASe,IAAT,GAAgB;AACZJ,MAAAA,aAAa,CAACG,OAAd,IAAyBH,aAAa,CAACG,OAAd,EAAzB;AACH;;AACD,QAAIT,gBAAgB,KAAK,IAArB,IAA6BI,SAAjC,EAA4C;AACxC,UAAIO,IAAI,GAAGC,WAAW,CAACF,IAAD,EAAOV,gBAAP,CAAtB;AACAE,MAAAA,aAAa,CAACO,OAAd,GAAwBE,IAAxB;AACA,aAAO,YAAY;AACfT,QAAAA,aAAa,CAACO,OAAd,GAAwB,IAAxB;AACAI,QAAAA,aAAa,CAACF,IAAD,CAAb;AACH,OAHD;AAIH;AACJ,GAZQ,EAYN,CAACX,gBAAD,EAAmBI,SAAnB,CAZM,CAAT;AAaA,MAAIU,OAAJ;AACAA,EAAAA,OAAO,GAAG,CAACP,KAAD,EAAQC,IAAR,EAAcN,aAAa,CAACO,OAA5B,CAAV;AACAK,EAAAA,OAAO,CAACP,KAAR,GAAgBA,KAAhB;AACAO,EAAAA,OAAO,CAACN,IAAR,GAAeA,IAAf;AACAM,EAAAA,OAAO,CAACC,UAAR,GAAqBb,aAAa,CAACO,OAAnC;AACA,SAAOK,OAAP;AACH;;AACD,SAAShB,WAAT","sourcesContent":["// See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nimport { useState, useEffect, useRef } from \"react\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\n/**\n *\n * useInterval hook\n *\n * Declaratively creates a setInterval to run a callback after a fixed\n * amount of time\n *\n *@param {funnction} callback - Callback to be fired\n *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired\n *@param {boolean} startImmediate - Whether the interval should start immediately on initialise\n *@returns {IntervalHandler}\n */\nfunction useInterval(callback, intervalDuration, startImmediate) {\n    if (startImmediate === void 0) { startImmediate = false; }\n    useWarningOnMountInDevelopment(\"useInterval is deprecated, it will be removed in rooks v7. Please use useIntervalWhen instead.\");\n    var internalIdRef = useRef(null);\n    var _a = useState(startImmediate), isRunning = _a[0], setIsRunning = _a[1];\n    var savedCallback = useRef();\n    function start() {\n        if (!isRunning) {\n            setIsRunning(true);\n        }\n    }\n    function stop() {\n        if (isRunning) {\n            setIsRunning(false);\n        }\n    }\n    // Remember the latest callback.\n    useEffect(function () {\n        savedCallback.current = callback;\n    });\n    // Set up the interval.\n    useEffect(function () {\n        function tick() {\n            savedCallback.current && savedCallback.current();\n        }\n        if (intervalDuration !== null && isRunning) {\n            var id_1 = setInterval(tick, intervalDuration);\n            internalIdRef.current = id_1;\n            return function () {\n                internalIdRef.current = null;\n                clearInterval(id_1);\n            };\n        }\n    }, [intervalDuration, isRunning]);\n    var handler;\n    handler = [start, stop, internalIdRef.current];\n    handler.start = start;\n    handler.stop = stop;\n    handler.intervalId = internalIdRef.current;\n    return handler;\n}\nexport { useInterval };\n"]},"metadata":{},"sourceType":"module"}