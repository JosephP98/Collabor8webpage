{"ast":null,"code":"// Massive respect for Josh Johnston\n// A lot of the logic is taken from his repo -> https://github.com/joshwnj/react-visibility-sensor\n// And is rewritten for hooks api\nimport { useEffect, useReducer } from \"react\";\nimport { useIsomorphicEffect } from \"./useIsomorphicEffect\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\n\nfunction normalizeRect(rect) {\n  if (rect.width === undefined) {\n    rect.width = rect.right - rect.left;\n  }\n\n  if (rect.height === undefined) {\n    rect.height = rect.bottom - rect.top;\n  }\n\n  return rect;\n}\n\nvar initialState = {\n  isVisible: null,\n  visibilityRect: {}\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"set\":\n      if (state.isVisible === action.payload.isVisible) {\n        return state;\n      }\n\n      return action.payload;\n\n    default:\n      return state;\n  }\n}\n\nvar DEFAULT_OPTIONS = {\n  containment: null,\n  intervalCheck: false,\n  minTopValue: 0,\n  partialVisibility: false,\n  resizeCheck: false,\n  resizeDebounce: 250,\n  resizeThrottle: -1,\n  scrollCheck: true,\n  scrollDebounce: 250,\n  scrollThrottle: -1,\n  shouldCheckOnMount: true\n};\n/**\n * useVisibilitySensor hook\n * Tracks the visibility of a ref\n *\n * @param ref The ref to track visibility of\n * @param opts Options\n */\n\nfunction useVisibilitySensor(ref, options) {\n  useWarningOnMountInDevelopment(\"useVisibilitySensor is deprecated, it will be removed in rooks v7. Please use useInViewRef instead.\");\n  /*\n      Create local state\n    */\n\n  var _a = useReducer(reducer, initialState),\n      localState = _a[0],\n      dispatch = _a[1];\n  /*\n      Get options\n    */\n\n\n  var _b = Object.assign({}, DEFAULT_OPTIONS, options),\n      containment = _b.containment,\n      intervalCheck = _b.intervalCheck,\n      scrollCheck = _b.scrollCheck,\n      shouldCheckOnMount = _b.shouldCheckOnMount,\n      scrollDebounce = _b.scrollDebounce,\n      scrollThrottle = _b.scrollThrottle,\n      resizeCheck = _b.resizeCheck,\n      resizeDebounce = _b.resizeDebounce,\n      resizeThrottle = _b.resizeThrottle,\n      partialVisibility = _b.partialVisibility,\n      minTopValue = _b.minTopValue;\n\n  function getContainer() {\n    return containment || window;\n  }\n  /*\n      Check visibility\n    */\n\n\n  function checkVisibility() {\n    var containmentRect;\n\n    if (containment) {\n      var containmentDOMRect = containment.getBoundingClientRect();\n      containmentRect = {\n        bottom: containmentDOMRect.bottom,\n        left: containmentDOMRect.left,\n        right: containmentDOMRect.right,\n        top: containmentDOMRect.top\n      };\n    } else {\n      containmentRect = {\n        bottom: window.innerHeight || document.documentElement.clientHeight,\n        left: 0,\n        right: window.innerWidth || document.documentElement.clientWidth,\n        top: 0\n      };\n    }\n\n    var rect = normalizeRect(ref.current.getBoundingClientRect());\n    var hasSize = rect.height > 0 && rect.width > 0;\n    var visibilityRect = {\n      bottom: rect.bottom <= containmentRect.bottom,\n      left: rect.left >= containmentRect.left,\n      right: rect.right <= containmentRect.right,\n      top: rect.top >= containmentRect.top\n    };\n    var isVisible = hasSize && visibilityRect.top && visibilityRect.left && visibilityRect.bottom && visibilityRect.right; // check for partial visibility\n\n    if (hasSize && partialVisibility) {\n      var partialVisible = rect.top <= containmentRect.bottom && rect.bottom >= containmentRect.top && rect.left <= containmentRect.right && rect.right >= containmentRect.left; // account for partial visibility on a single edge\n\n      if (typeof partialVisibility === \"string\") {\n        partialVisible = visibilityRect[partialVisibility];\n      } // if we have minimum top visibility set by props, lets check, if it meets the passed value\n      // so if for instance element is at least 200px in viewport, then show it.\n\n\n      isVisible = minTopValue ? partialVisible && rect.top <= containmentRect.bottom - minTopValue : partialVisible;\n    }\n\n    return {\n      isVisible: isVisible,\n      visibilityRect: visibilityRect\n    };\n  }\n\n  function updateIsVisible() {\n    if (!ref.current) {\n      return;\n    }\n\n    var _a = checkVisibility(),\n        isVisible = _a.isVisible,\n        visibilityRect = _a.visibilityRect;\n\n    dispatch({\n      payload: {\n        isVisible: isVisible,\n        visibilityRect: visibilityRect\n      },\n      type: \"set\"\n    });\n  } // run only once, hence empty array as second argument\n\n\n  useEffect(function () {\n    if (shouldCheckOnMount) {\n      updateIsVisible();\n    }\n  }, []);\n  useEffect(function () {\n    updateIsVisible();\n  }, [ref.current]); // If interval check is needed\n\n  useEffect(function () {\n    if (intervalCheck && intervalCheck > 0) {\n      var intervalTimer_1 = setInterval(function () {\n        updateIsVisible();\n      }, intervalCheck);\n      return function () {\n        clearInterval(intervalTimer_1);\n      };\n    }\n  }, [intervalCheck]);\n\n  function createListener(event, debounce, throttle) {\n    var container = getContainer();\n    var timeout;\n    var listener;\n\n    var later = function () {\n      timeout = null;\n      updateIsVisible();\n    };\n\n    if (throttle > -1) {\n      listener = function () {\n        if (!timeout) {\n          timeout = setTimeout(later, throttle || 0);\n        }\n      };\n    } else {\n      listener = function () {\n        clearTimeout(timeout);\n        timeout = setTimeout(later, debounce || 0);\n      };\n    }\n\n    container.addEventListener(event, listener);\n    return function () {\n      clearTimeout(timeout);\n      container.removeEventListener(event, listener);\n    };\n  } // If scroll check is needed\n\n\n  useIsomorphicEffect(function () {\n    if (scrollCheck) {\n      return createListener(\"scroll\", scrollDebounce, scrollThrottle);\n    }\n  }, []); // if resize check is needed\n\n  useIsomorphicEffect(function () {\n    if (resizeCheck) {\n      return createListener(\"resize\", resizeDebounce, resizeThrottle);\n    }\n  }, []);\n  return localState;\n}\n\nexport { useVisibilitySensor };","map":{"version":3,"sources":["D:/react/productwebsite/node_modules/rooks/dist/esm/hooks/useVisibilitySensor.js"],"names":["useEffect","useReducer","useIsomorphicEffect","useWarningOnMountInDevelopment","normalizeRect","rect","width","undefined","right","left","height","bottom","top","initialState","isVisible","visibilityRect","reducer","state","action","type","payload","DEFAULT_OPTIONS","containment","intervalCheck","minTopValue","partialVisibility","resizeCheck","resizeDebounce","resizeThrottle","scrollCheck","scrollDebounce","scrollThrottle","shouldCheckOnMount","useVisibilitySensor","ref","options","_a","localState","dispatch","_b","Object","assign","getContainer","window","checkVisibility","containmentRect","containmentDOMRect","getBoundingClientRect","innerHeight","document","documentElement","clientHeight","innerWidth","clientWidth","current","hasSize","partialVisible","updateIsVisible","intervalTimer_1","setInterval","clearInterval","createListener","event","debounce","throttle","container","timeout","listener","later","setTimeout","clearTimeout","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["// Massive respect for Josh Johnston\n// A lot of the logic is taken from his repo -> https://github.com/joshwnj/react-visibility-sensor\n// And is rewritten for hooks api\nimport { useEffect, useReducer } from \"react\";\nimport { useIsomorphicEffect } from \"./useIsomorphicEffect\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\nfunction normalizeRect(rect) {\n    if (rect.width === undefined) {\n        rect.width = rect.right - rect.left;\n    }\n    if (rect.height === undefined) {\n        rect.height = rect.bottom - rect.top;\n    }\n    return rect;\n}\nvar initialState = { isVisible: null, visibilityRect: {} };\nfunction reducer(state, action) {\n    switch (action.type) {\n        case \"set\":\n            if (state.isVisible === action.payload.isVisible) {\n                return state;\n            }\n            return action.payload;\n        default:\n            return state;\n    }\n}\nvar DEFAULT_OPTIONS = {\n    containment: null,\n    intervalCheck: false,\n    minTopValue: 0,\n    partialVisibility: false,\n    resizeCheck: false,\n    resizeDebounce: 250,\n    resizeThrottle: -1,\n    scrollCheck: true,\n    scrollDebounce: 250,\n    scrollThrottle: -1,\n    shouldCheckOnMount: true,\n};\n/**\n * useVisibilitySensor hook\n * Tracks the visibility of a ref\n *\n * @param ref The ref to track visibility of\n * @param opts Options\n */\nfunction useVisibilitySensor(ref, options) {\n    useWarningOnMountInDevelopment(\"useVisibilitySensor is deprecated, it will be removed in rooks v7. Please use useInViewRef instead.\");\n    /*\n        Create local state\n      */\n    var _a = useReducer(reducer, initialState), localState = _a[0], dispatch = _a[1];\n    /*\n        Get options\n      */\n    var _b = Object.assign({}, DEFAULT_OPTIONS, options), containment = _b.containment, intervalCheck = _b.intervalCheck, scrollCheck = _b.scrollCheck, shouldCheckOnMount = _b.shouldCheckOnMount, scrollDebounce = _b.scrollDebounce, scrollThrottle = _b.scrollThrottle, resizeCheck = _b.resizeCheck, resizeDebounce = _b.resizeDebounce, resizeThrottle = _b.resizeThrottle, partialVisibility = _b.partialVisibility, minTopValue = _b.minTopValue;\n    function getContainer() {\n        return containment || window;\n    }\n    /*\n        Check visibility\n      */\n    function checkVisibility() {\n        var containmentRect;\n        if (containment) {\n            var containmentDOMRect = containment.getBoundingClientRect();\n            containmentRect = {\n                bottom: containmentDOMRect.bottom,\n                left: containmentDOMRect.left,\n                right: containmentDOMRect.right,\n                top: containmentDOMRect.top,\n            };\n        }\n        else {\n            containmentRect = {\n                bottom: window.innerHeight || document.documentElement.clientHeight,\n                left: 0,\n                right: window.innerWidth || document.documentElement.clientWidth,\n                top: 0,\n            };\n        }\n        var rect = normalizeRect(ref.current.getBoundingClientRect());\n        var hasSize = rect.height > 0 && rect.width > 0;\n        var visibilityRect = {\n            bottom: rect.bottom <= containmentRect.bottom,\n            left: rect.left >= containmentRect.left,\n            right: rect.right <= containmentRect.right,\n            top: rect.top >= containmentRect.top,\n        };\n        var isVisible = hasSize &&\n            visibilityRect.top &&\n            visibilityRect.left &&\n            visibilityRect.bottom &&\n            visibilityRect.right;\n        // check for partial visibility\n        if (hasSize && partialVisibility) {\n            var partialVisible = rect.top <= containmentRect.bottom &&\n                rect.bottom >= containmentRect.top &&\n                rect.left <= containmentRect.right &&\n                rect.right >= containmentRect.left;\n            // account for partial visibility on a single edge\n            if (typeof partialVisibility === \"string\") {\n                partialVisible = visibilityRect[partialVisibility];\n            }\n            // if we have minimum top visibility set by props, lets check, if it meets the passed value\n            // so if for instance element is at least 200px in viewport, then show it.\n            isVisible = minTopValue\n                ? partialVisible && rect.top <= containmentRect.bottom - minTopValue\n                : partialVisible;\n        }\n        return { isVisible: isVisible, visibilityRect: visibilityRect };\n    }\n    function updateIsVisible() {\n        if (!ref.current) {\n            return;\n        }\n        var _a = checkVisibility(), isVisible = _a.isVisible, visibilityRect = _a.visibilityRect;\n        dispatch({\n            payload: { isVisible: isVisible, visibilityRect: visibilityRect },\n            type: \"set\",\n        });\n    }\n    // run only once, hence empty array as second argument\n    useEffect(function () {\n        if (shouldCheckOnMount) {\n            updateIsVisible();\n        }\n    }, []);\n    useEffect(function () {\n        updateIsVisible();\n    }, [ref.current]);\n    // If interval check is needed\n    useEffect(function () {\n        if (intervalCheck && intervalCheck > 0) {\n            var intervalTimer_1 = setInterval(function () {\n                updateIsVisible();\n            }, intervalCheck);\n            return function () {\n                clearInterval(intervalTimer_1);\n            };\n        }\n    }, [intervalCheck]);\n    function createListener(event, debounce, throttle) {\n        var container = getContainer();\n        var timeout;\n        var listener;\n        var later = function () {\n            timeout = null;\n            updateIsVisible();\n        };\n        if (throttle > -1) {\n            listener = function () {\n                if (!timeout) {\n                    timeout = setTimeout(later, throttle || 0);\n                }\n            };\n        }\n        else {\n            listener = function () {\n                clearTimeout(timeout);\n                timeout = setTimeout(later, debounce || 0);\n            };\n        }\n        container.addEventListener(event, listener);\n        return function () {\n            clearTimeout(timeout);\n            container.removeEventListener(event, listener);\n        };\n    }\n    // If scroll check is needed\n    useIsomorphicEffect(function () {\n        if (scrollCheck) {\n            return createListener(\"scroll\", scrollDebounce, scrollThrottle);\n        }\n    }, []);\n    // if resize check is needed\n    useIsomorphicEffect(function () {\n        if (resizeCheck) {\n            return createListener(\"resize\", resizeDebounce, resizeThrottle);\n        }\n    }, []);\n    return localState;\n}\nexport { useVisibilitySensor };\n"]},"metadata":{},"sourceType":"module"}